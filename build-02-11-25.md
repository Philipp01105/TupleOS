# Build Log - February 11, 2025

## What we did

Implemented Phase 3 Step 6: the ELF loader. This is the code in stage2's 32-bit protected mode section that takes the raw kernel ELF binary (which FAT16 loaded to physical 0x10000) and copies its PT_LOAD segments to their correct physical addresses at 0x100000+. It also zero-fills BSS and saves the entry point for the eventual kernel handoff in Step 9.

The ELF loader validates the header (magic, class, endianness, type, machine), extracts the program header table location, then loops over each program header. For each PT_LOAD segment it does a `rep movsb` from the ELF file offset to `p_paddr`, then a `rep stosb` to zero-fill any remaining bytes between `p_filesz` and `p_memsz` (the BSS region).

We also updated build.sh to build the real kernel ELF via the existing Makefile and copy it onto the FAT16 image, replacing the old placeholder file.

## The bug

After implementing everything, the ELF loader reported `[FAIL] Invalid ELF binary!`. The magic check at 0x10000 was seeing all zeros instead of `7F 45 4C 46`.

We confirmed the kernel ELF was valid on disk (xxd showed the magic bytes at the correct LBA), and the FAT16 driver was printing "kernel loaded to 0x10000" with no errors. So the question was: why is 0x10000 empty after the load?

### Debugging

First we suspected the LBA extended read (INT 0x13 AH=0x42) might have trouble writing to segment 0x1000. We added diagnostics:

1. Manual write test: wrote 0xBEEF to 0x1000:0x0000 and read it back. Worked fine. Memory at physical 0x10000 was accessible.

2. CHS read test: read the first data sector to 0x1000:0x0000 via AH=0x02. It overwrote the 0xBEEF (proving it did write to the right address) but the data was zeros. At the time this looked like an INT 0x13 segment issue.

3. The breakthrough: we printed `fat16_data_start` and `spc` to verify the FAT16 geometry, then added a comparison test that read the same LBA to segment 0 (instead of segment 0x1000) through the same `read_sectors` function.

The results:

```
cluster=0x0E00
[0x1000:0]=0x0000
seg0 read=0x457F
```

The segment 0 read returned 0x457F, which is the first two bytes of the ELF magic (`7F 45` as a little-endian word). So the data was on disk at the right LBA, and INT 0x13 could read it just fine. The problem was that `fat16_load_file` was computing the wrong LBA because it received the wrong cluster number.

### Root cause

`cluster=0x0E00` was the giveaway. 0x0E is the BIOS teletype function number, and 0x00 is a null terminator. This is exactly what AX looks like after `print_string` finishes its loop.

In `fat16_find_file`, the `.find_found` path did this:

```asm
mov ax, [di + 0x1A]     ; AX = first cluster (correct value, probably 2)
pop cx
mov si, msg_fat16_found
call print_string        ; prints "FAT16: file found, loading..."
ret                      ; AX is now 0x0E00, not the cluster number
```

`print_string` is a loop that calls `lodsb` (which loads into AL) and `mov ah, 0x0E` (the BIOS teletype function). When it hits the null terminator, AL=0x00 and AH=0x0E from the previous iteration. So AX = 0x0E00 when the function returns.

The caller then passed this garbage cluster number to `fat16_load_file`, which computed:

```
lba = data_start + (0x0E00 - 2) * 4 = 132 + 14328 = 14460
```

LBA 14460 is way out in unwritten disk space, so it read zeros. The actual kernel was at cluster 2 (LBA 132).

### Fix

Two lines:

```asm
mov ax, [di + 0x1A]     ; first cluster number
pop cx

push ax                  ; save cluster number (print_string clobbers AX)
mov si, msg_fat16_found
call print_string
pop ax                   ; restore cluster number
ret
```

After the fix, `cluster=0x0002`, the kernel loaded correctly, and the ELF loader reported:

```
ELF: loaded, entry 0x0010000C
```

Which is exactly right: `_start` sits 12 bytes into the `.boot` section (after the 12-byte multiboot header) at physical address 0x10000C.

### Lesson

In real-mode x86 assembly, almost every BIOS interrupt and string routine clobbers AX. Any time you have a value in AX that you need to survive a function call, push it first. This is easy to miss because the clobbering happens inside the callee (through `lodsb`, `mov ah, <function>`, etc.) and the caller looks perfectly clean on its own.
